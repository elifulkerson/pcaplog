#!/usr/bin/python3

"""
This is part of "PCAPLOG.2", by Eli Fulkerson
7/6/2023
see https://elifulkerson.com for updates

This script is used in conjunction with pcaplog2.lua, which should be placed
in the appropriate wireshark directory.
(For instance ~/.local/lib/wireshark/plugins)

PCAPLOG is run as a 'prefix' to another command, in the same way that the unix "time" command
can be used.   When used in this way, it will send the command line arguments as well as the
individual lines of stdout generated by the command over the network to be collected by Wireshark.

Syntax:   (e.g.)
    # add an arbitrary log line to the log
    ./pcaplog rem This is a remark that we would like to add to PCAP

    # "watch" a log file, send any new lines added to the file to PCAP
    ./pcaplog file FILENAME.txt

    # run a command, send the output to PCAP
    ./pcaplog ping 127.0.0.1

    # run a command, pipe the output to PCAP
    ping 127.0.0.1 | ./pcaplog

The purpose of this is to allow exact correlation of what-you-typed-in-the-terminal and the
network behavior that was observed in response.

The pcaplog will include the protocol version, mode, the UTC time, a unique hash string for
each command (to aid in correlation, it's annoying to search for date strings), the current
user@hostname and the data itself.

Potential upgrades:
- parse the command line, capture and log hashes/versions of binaries run or payloads sent?
- It would be nice to change the color, but since these packets get an ICMP unreachable
  response, Wireshark will always color them red with the other network errors.
- Some level of encryption - encrypt in python, decrypt in lua.  Not sure how much
  you can do in terms of including additional libraries in the context of the wireshark
  plugin environment.
"""

"User editable options"

# The target IP address needs to be directional - that is, traffic sent from your computer needs
# to be routed in the appropriate direction in order to be picked up by your packet capture host.
# (which might not be on the same PC).  Adjust this value if necessary to the correct "over there".
# You can also adjust to an arbitrary number for easier filtering in Wireshark if you desire as
# long as the routing passes over your capture interface (for instance, 127.0.0.1 will never work)
TARGETIP = "8.8.8.8"

# This is the TTL used to send the logging packets
# Keep the TTL as low as possible so that you can never reach TARGETIP.  For localhost, this is always 1.
# you can raise this if necessary in order to get the traffic to reach your packet capture host.
TTL = 1

# Do we dispaly the "hash" on stdout on the local machine?  This exists so that you can correlate
# the hash shown on the terminal output with the hash found in the pcap, but it might be spammy/
MODE_DISPLAY_HASH_ONCE = True  # just show it the once per invocation
MODE_DISPLAY_HASH_ALWAYS = True # show hash on every input line

# Do we send the command you typed to the log?
MODE_LOG_CMD = True

# Do we send the stdout returned by that command to the log?
MODE_LOG_STDOUT = True

# watchfile mode, after checking for new lines in the file, we sleep OPT_DELAY seconds
# @@ todo apply this to the stderr/stdout too
OPT_DELAY = 0.01

"Don't edit these"
# Don't edit these options without also modifying the lua plugin to match
PROTOCOLNAME = "PCAPLOG"
VERSION = "2"
DELIM = "\n"  # newline shouldn't appear in a single cmdline...
UDPDISCARD = 9  # "discard" protocol rfc863
GROUP_HASH = None

import sys
import datetime
import os
import socket
import subprocess
import hashlib
import signal
import time
import datetime


HIGHLIGHT = '\033[90m'
RESET = '\033[0m'

# handle control-c, just so we don't get spam when killing the subshell
def handler(signum, frame):
    sys.exit(1)
signal.signal(signal.SIGINT, handler)

def buildmessage(mode="", text=""):

    global GROUP_HASH

    message_dict = {}
    message_dict["ver"] = f"{PROTOCOLNAME}.{VERSION}"
    message_dict["mode"] = mode
    message_dict["timestamp"] = datetime.datetime.now().isoformat()

    message_dict["timehash"] = hashlib.sha256(message_dict["timestamp"].encode()).hexdigest()[0:16] # cut this down to 1/4, should still be unique enough on most days

    # group hash is unique for a single invocation - so anything from the same popen, pipe or logfile should be groupable by this field.
    if GROUP_HASH == None:
        GROUP_HASH = message_dict["timehash"]

        # sending to stderr so we don't break any pipe use 
        if MODE_DISPLAY_HASH_ONCE:
            sys.stderr.write(f"{HIGHLIGHT}timestamp:{message_dict['timestamp']}{RESET} {HIGHLIGHT}timehash:{message_dict['timehash']}{RESET} {HIGHLIGHT}grouphash:{GROUP_HASH}{RESET}\n")
            sys.stderr.flush()
    else:
        if MODE_DISPLAY_HASH_ALWAYS:
            sys.stderr.write(f"{HIGHLIGHT}timestamp:{message_dict['timestamp']}{RESET} {HIGHLIGHT}timehash:{message_dict['timehash']}{RESET} {HIGHLIGHT}grouphash:{GROUP_HASH}{RESET}\n")
            sys.stderr.flush()


    message_dict["groupby"] = GROUP_HASH

    message_dict["user"] = f"{os.getlogin()}@{socket.gethostname()}"
    message_dict["text"] = text


    message = DELIM.join([f"{key}:{value}" for key, value in message_dict.items()])

    message = bytes(message, "utf-8")

    return message


def watchfile(filename, s):

    file = open(filename, "r")

    # We aren't interested in pre-existing lines, as they don't have timing with the pcap and the file may be large
    junk = file.readlines()
    linecount = len(junk)
    print(f"-- opening {filename}, {linecount} pre-existing lines skipped")

    while True:
        point = file.tell()
        line = file.readline().strip()
        if not line:
            time.sleep(OPT_DELAY)
            file.seek(point)
        else:
            linecount += 1
            message = buildmessage(mode="file", text=f"{filename}:{linecount} {line}")
            print(f"{filename}:{linecount} {line}")
            s.sendto(message, (TARGETIP, UDPDISCARD))

    return 0


def logcommand(cmd, s):

    # send the cmd itself
    if MODE_LOG_CMD:
        message = buildmessage(mode="cmd", text=cmd)
        s.sendto(message, (TARGETIP, UDPDISCARD))

    # Now we run the command, optionally sending each line of its stdout to the pcaplog as well
    my_env = os.environ.copy()

    proc = subprocess.Popen(
        cmd, executable="/bin/bash", shell=True, stdout=subprocess.PIPE, env=my_env
    )

    for line in proc.stdout:
        line = line.decode("utf-8")
        sys.stdout.write(line)
        sys.stdout.flush()

        if MODE_LOG_STDOUT:
            message = buildmessage(mode="out", text=line)
            s.sendto(message, (TARGETIP, UDPDISCARD))

    return 0


def logremark(text, s):
    
    message = buildmessage(mode="rem", text=text)
    s.sendto(message, (TARGETIP, UDPDISCARD))

    return 0


def logpipe(s):
    for line in sys.stdin:

        message = buildmessage(mode="pipe", text=line)
        s.sendto(message, (TARGETIP, UDPDISCARD))

        sys.stdout.write(line)
        sys.stdout.flush()



def main():

    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.setsockopt(socket.IPPROTO_IP, socket.IP_TTL, TTL)

    # not quite an arg parse - since this is a "prefix" command I want to keep this to an absolute minimum

    # pipe mode
    if len(sys.argv) == 1:
        logpipe(s)

    if sys.argv[1] == "rem":
        remark = " ".join(sys.argv[2:])
        logremark(remark,s)

    elif sys.argv[1] == "file":
        watchfile(sys.argv[2],s)

    else:
        cmd = " ".join(sys.argv[1:])
        logcommand(cmd,s)

    return 0


if __name__ == "__main__":
    status = main()
    sys.exit(status)
